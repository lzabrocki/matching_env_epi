---
title: "Propensity Score Matching"
description: |
  Detailled Script.
author:
  - name: Tarik Benmarhnia 
    url: https://profiles.ucsd.edu/tarik.benmarhnia
    affiliation: University of California San Diego
    affiliation_url: https://profiles.ucsd.edu/tarik.benmarhnia
  - name: Marie-Abèle Bind 
    url: https://scholar.google.com/citations?user=gyPCRcEAAAAJ&hl=fr
    affiliation: 	Massachusetts General Hospital
    affiliation_url: https://scholar.google.com/citations?user=gyPCRcEAAAAJ&hl=fr
  - name: Léo Zabrocki 
    url: https://www.parisschoolofeconomics.eu/en/
    affiliation: Paris School of Economics
    affiliation_url: https://www.parisschoolofeconomics.eu/en/
date: "`r Sys.Date()`"
output: 
    distill::distill_article:
      toc: true
      toc_depth: 3
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(message = FALSE, warning = FALSE)
```

<style>
body {
text-align: justify}
</style>

In this document, we provide all steps and R codes required to estimate the effect of heat waves of the number of years of life lost (YoLL) using propensity score matching. The implementation is done with the fantastic package [MatchIt](https://kosukeimai.github.io/MatchIt/index.html): do not hesitate to explore its very well-made documentation. We also rely on the [cobalt]()**Should you have any questions, need help to reproduce the analysis or find coding errors, please do not hesitate to contact us at leo.zabrocki@psemail.eu**

# Required Packages and Data Loading

To reproduce exactly the `4_propensity_score_matching.html` document, we first need to have installed:

* the [R](https://www.r-project.org/) programming language 
* [RStudio](https://rstudio.com/), an integrated development environment for R, which will allow you to knit the `4_propensity_score_matching.Rmd` file and interact with the R code chunks
* the [R Markdown](https://rmarkdown.rstudio.com/) package
* and the [Distill](https://rstudio.github.io/distill/) package which provides the template for this document. 

Once everything is set up, we load the following packages:

```{r, echo = TRUE}
# load required packages
library(knitr) # for creating the R Markdown document
library(here) # for files paths organization
library(tidyverse) # for data manipulation and visualization
library(broom) # for cleaning regression outputs
library(MatchIt) # for matching procedures
library(cobalt) # for assessing covariates balance
library(lmtest) # for modifying regression standard errors
library(sandwich) # for robust and cluster robust standard errors
library(Cairo) # for printing custom police of graphs
library(DT) # for displaying the data as tables
```

We load our custom `ggplot2` theme for graphs:

```{r, echo = TRUE}
# load ggplot custom theme
source(here::here(
  "2.scripts",
  "functions",
  "script_theme_tufte.R"
))
# define nice colors
my_blue <- "#0081a7"
my_orange <- "#fb8500"
```

We finally load the data:

```{r, echo = TRUE}
# load the data
data <-
  readRDS(here::here("1.data", "simulated_environmental_data.rds")) %>%
  # define week and year as factors
  mutate_at(vars(week, year), ~ as.factor(.))
```

As a reminder, there are `r nrow(data %>% filter(heat_wave==1))` days where an heat wave occurred and `r nrow(data %>% filter(heat_wave==0))` days without heat waves.

# Propensity Score Matching

We first implement below a propensity score matching procedure where:

*  each day with an heat wave is matched to the most similar day without heat wave (1:1 nearest neighbor matching without replacement)
* the distance metric used for the matching is the propensity score which is predicted using a logistic model where we regress the heat wave dummy on its three lags, the three lags of ozone, nitrogen dioxide and its three lags, the relative humidity, the calendar indicators for the day of the week, the week and the year.

We vary the matching distance to see how covariates balance change:

1. We first match each treated unit to its closest control unit.
2. We then set the maximum distance (i.e., the caliper) allowed between a treated and control unit to be inferior 0.5 propensity score standard deviation. 

Once treated and control units are matched, we assess whether covariates has improved. 

We finally estimate the treatment effect.

### Matching Procedure and Covariates Balance Improvement

We first match each treated unit to its closest control unit without any caliper using the `matchit()` function:

```{r, echo = TRUE}
# match without caliper
matching_ps_no_calliper <-
  matchit(
    heat_wave ~ heat_wave_lag_1 + heat_wave_lag_2 + heat_wave_lag_3 + o3_lag_1 + o3_lag_2 + o3_lag_3 + no2 + no2_lag_1 + no2_lag_2 + no2_lag_3 + humidity_relative + month + week + year,
    data = data
  )

# display summary of the procedure
matching_ps_no_calliper
```

The output of the matching procedure indicates us the method (1:1 nearest neighbor matching without replacement) and the distance (propensity score) we used. It also tells us how many treated units were matched: `r matching_ps_no_calliper[["nn"]][3]` (all treated units were matched). We assess how covariates balance has improved by comparing the distribution of propensity scores before and after matching: 

```{R, echo=TRUE, layout="l-body-outset", fig.width = 10, fig.height = 6, dev = "CairoPNG"}
# distribution of propensity scores
bal.plot(
  matching_ps_no_calliper,
  var.name = "distance",
  which = "both",
  sample.names = c("Initial Data", "Matched Data"),
  type = "density"
) +
  ggtitle("Distribution of the Propensity Score Before and After Matching") +
  xlab("Propensity Scores") +
  scale_fill_manual(name = "Group:", values = c(my_orange, my_blue), labels = c("Days without Heat Waves", "Days with Heat Waves")) +
  theme_tufte()
```

We see on this graph that propensity scores distribution for the two groups better overlap after matching. We can also evaluate the covariates balance using the `love.plot()` function from the cobalt package and the standardized mean difference as the summary statistic:

```{R, echo=TRUE, layout="l-body-outset", fig.width = 8, fig.height = 8, dev = "CairoPNG"}
# first we nicely label covariates
cov_labels <- c(
  heat_wave_lag_1 = "Heat Wave t-1",
  heat_wave_lag_2 = "Heat Wave t-2",
  heat_wave_lag_3 = "Heat Wave t-3",
  o3_lag_1 = "O3 t-1",
  o3_lag_2 = "O3 t-2",
  o3_lag_3 = "O3 t-3",
  no2 = "NO2",
  no2_lag_1 = "NO2 t-1",
  no2_lag_2 = "NO2 t-2",
  no2_lag_3 = "NO2 t-3",
  humidity_relative = "Relative Humidity",
  month_august = "August",
  month_june = "June",
  month_july = "July",
  week_22 = "Week 22",
  week_23 = "Week 23",
  week_24 = "Week 24",
  week_25 = "Week 25",
  week_26 = "Week 26",
  week_27 = "Week 27",
  week_28 = "Week 28",
  week_29 = "Week 29",
  week_30 = "Week 30",
  week_31 = "Week 31",
  week_32 = "Week 32",
  week_33 = "Week 33",
  week_34 = "Week 34",
  week_35 = "Week 35",
  year_1990 = "1990",
  year_1991 = "1991",
  year_1992 = "1992",
  year_1993 = "1993",
  year_1994 = "1994",
  year_1995 = "1995",
  year_1996 = "1996",
  year_1997 = "1997",
  year_1998 = "1998",
  year_1999 = "1999",
  year_2000 = "2000",
  year_2001 = "2001",
  year_2002 = "2002",
  year_2003 = "2003",
  year_2004 = "2004",
  year_2005 = "2005",
  year_2006 = "2006",
  year_2007 = "2007"
)

# make the love plot
love.plot(
  matching_ps_no_calliper,
  drop.distance = TRUE,
  abs = TRUE,
  var.order = "unadjusted",
  binary = "std",
  thresholds = c(m = .1),
  var.names = cov_labels,
  sample.names = c("Initial Data", "Matched Data"),
  shapes = c("circle", "triangle"),
  colors = c(my_orange, my_blue)
) +
  xlab("Absolute Standardized mean Differences") +
theme_tufte()
```

On this graph, we can see that for most covariates balance has improved after matching---yet, for few covariates, the standardized mean difference has increased.


Until now, we matched each treated unit to its closest control unit: we could however make sure that a treated unit is not matched to a control unit which is too much different. We do so by setting a caliper, the maximum distance in terms of proposenstiy score standard deviation allows between a treated and control. We below implement the same propensity score matching but with a caliper of 0.5:

```{r, echo = TRUE}
# match without caliper
matching_ps_w_calliper <-
  matchit(
    heat_wave ~ heat_wave_lag_1 + heat_wave_lag_2 + heat_wave_lag_3 + o3_lag_1 + o3_lag_2 + o3_lag_3 + no2 + no2_lag_1 + no2_lag_2 + no2_lag_3 + humidity_relative + month + week + year,
    caliper = 0.1,
    data = data
  )

# display summary of the procedure
matching_ps_w_calliper
```

Compared to the matching without caliper, there are now `r matching_ps_w_calliper[["nn"]][3]`` matched treated units. We can check whether the propensity score distributions overlap better:

```{R, echo=TRUE, layout="l-body-outset", fig.width = 10, fig.height = 6, dev = "CairoPNG"}
# distribution of propensity scores
bal.plot(
  matching_ps_w_calliper,
  var.name = "distance",
  which = "both",
  sample.names = c("Initial Data", "Matched Data"),
  type = "density"
) +
  ggtitle("Distribution of the Propensity Score Before and After Matching") +
  xlab("Propensity Scores") +
  scale_fill_manual(name = "Group:", values = c(my_orange, my_blue), labels = c("Days without Heat Waves", "Days with Heat Waves")) +
  theme_tufte()
```

It seems to be better than the matching without caliper. We can also evaluate how each covariate balance has improved with a love plot:

```{R, echo=TRUE, layout="l-body-outset", fig.width = 8, fig.height = 8, dev = "CairoPNG"}
# make the love plot

love.plot(
  heat_wave ~ heat_wave_lag_1 + heat_wave_lag_2 + heat_wave_lag_3 + o3_lag_1 + o3_lag_2 + o3_lag_3 + no2 + no2_lag_1 + no2_lag_2 + no2_lag_3 + humidity_relative + month + week + year,
  data = data,
  estimand = "ATT",
  weights = list("Without Caliper" = matching_ps_no_calliper,
                 "With Caliper" = matching_ps_w_calliper),
  drop.distance = TRUE,
  abs = TRUE,
  var.order = "unadjusted",
  binary = "std",
  thresholds = c(m = .1),
  var.names = cov_labels,
  sample.names = c("Initial Data", "Without Caliper", "With Caliper"),
  shapes = c("circle", "triangle", "square"),
  colors = c(my_orange, my_blue, "#81b29a")
) +
  xlab("Absolute Standardized mean Differences") +
  theme_tufte()
```

On this graph, it is not clear to see whether covariates balance has really increased.

### Analysis of Matched Data

We now move to the analysis of the matched datasets using a simple regression model where we first regression the YoLL on the treatment indicator. We start with the matched data resulting from the propensity score without caliper:

```{R, echo=TRUE}
# we retrieve the matched data
data_ps_no_calliper <- match.data(matching_ps_no_calliper)

# we fit the regression model
model_ps_no_calliper <- lm(y_obs ~ heat_wave,
                               data = data_ps_no_calliper,
                               weights = weights)

# retrieve the estimate and 95% ci
results_ps_no_calliper <- tidy(coeftest(
  model_ps_no_calliper,
  vcov. = vcovCL,
  cluster = ~ subclass
),
conf.int = TRUE) %>%
  filter(term == "heat_wave") %>%
  select(term, estimate, conf.low, conf.high) %>%
  mutate_at(vars(estimate:conf.high), ~ round(., 0))

# display results
results_ps_no_calliper %>%
  rename(
    "Term" = term,
    "Estimate" = estimate,
    "95% CI Lower Bound" = conf.low,
    "95% CI Upper Bound" = conf.high
  ) %>%
  kable(., align = c("l", "c", "c", "c"))
```

We find that the average effect on the treated is equal to +`r results_ps_no_calliper$estimate` years of life lost. The 95% confidence interval is consistent with effects ranging from +`r results_ps_no_calliper$conf.low` up to +`r results_ps_no_calliper$conf.high`. The estimate of the ATT is still far from the the true effect of +230 YoLL. If we want to increase the precision of our estimate and remove any remaining imbalance in covariates, we can also run a multivariate regression. We adjust below for the same variables used in the estimation of propensity scores:

```{R, echo=TRUE}
# we fit the regression model
model_ps_no_calliper_w_cov <-
  lm(
    y_obs ~ heat_wave + heat_wave_lag_1 + heat_wave_lag_2 + heat_wave_lag_3 + o3_lag_1 + o3_lag_2 + o3_lag_3 + no2 + no2_lag_1 + no2_lag_2 + no2_lag_3 + humidity_relative + month + week + year,
    data = data_ps_no_calliper,
    weights = weights
  )

# retrieve the estimate and 95% ci
results_ps_no_calliper_w_cov <- tidy(coeftest(
  model_ps_no_calliper_w_cov,
  vcov. = vcovCL,
  cluster = ~ subclass
),
conf.int = TRUE) %>%
  filter(term == "heat_wave") %>%
  select(term, estimate, conf.low, conf.high) %>%
  mutate_at(vars(estimate:conf.high), ~ round(., 0))

# display results
results_ps_no_calliper_w_cov %>%
  rename(
    "Term" = term,
    "Estimate" = estimate,
    "95% CI Lower Bound" = conf.low,
    "95% CI Upper Bound" = conf.high
  ) %>%
  kable(., align = c("l", "c", "c", "c"))
```


We find that the average effect on the treated is equal to +`r results_ps_no_calliper_w_cov$estimate` years of life lost: the estimate is closer to the true effect. The 95% confidence interval is consistent with effects ranging from +`r results_ps_no_calliper_w_cov$conf.low` up to +`r results_ps_no_calliper_w_cov$conf.high`. The width of confidence interval is now equal to `r results_ps_no_calliper_w_cov$conf.high - results_ps_no_calliper_w_cov$conf.low`, which is half smaller than the previous interval of `r results_ps_no_calliper$conf.high - results_ps_no_calliper$conf.low`.

We also estimate the treatment effect for the matched dataset resulting from the matching procedure with a caliper. It is very important to note that the target causal estimand is not anymore the the average treatment on the treated as not all treated units could be matched to similar control units. To know the true causal effect for the match data, we compute the mean difference in potential outcomes:

```{R, echo=TRUE}
# we retrieve the matched data
data_ps_w_calliper <- match.data(matching_ps_w_calliper)

# compute the true effect for the data
true_att_ps__w_calliper <-
  round(mean(data_ps_w_calliper$y_1[data_ps_w_calliper$heat_wave == 1] - data_ps_w_calliper$y_0[data_ps_w_calliper$heat_wave == 0]), 0)
```

The true effect for this match data is equal to +`r true_att_ps__w_calliper` YoLL, which is different for the true effect on **all** treated units. If we estimate this effect with a simple linear regression model, we get:

```{R, echo=TRUE}
# we fit the regression model
model_ps_w_calliper <- lm(y_obs ~ heat_wave,
                               data = data_ps_w_calliper,
                               weights = weights)

# retrieve the estimate and 95% ci
results_ps_w_calliper <- tidy(coeftest(
  model_ps_w_calliper,
  vcov. = vcovCL,
  cluster = ~ subclass
),
conf.int = TRUE) %>%
  filter(term == "heat_wave") %>%
  select(term, estimate, conf.low, conf.high) %>%
  mutate_at(vars(estimate:conf.high), ~ round(., 0))

# display results
results_ps_w_calliper %>%
  rename(
    "Term" = term,
    "Estimate" = estimate,
    "95% CI Lower Bound" = conf.low,
    "95% CI Upper Bound" = conf.high
  ) %>%
  kable(., align = c("l", "c", "c", "c"))
```

The estimated is exactly equal to the true effect of +`r true_att_ps__w_calliper`. The 95% confidence interval is consistent with effects ranging from +`r results_ps_w_calliper$conf.low` up to +`r results_ps_w_calliper$conf.high`. We finally run the regression model where we adjust for covariates:

```{R, echo=TRUE}
# we fit the regression model
model_ps_w_calliper_w_cov <-
  lm(
    y_obs ~ heat_wave + heat_wave_lag_1 + heat_wave_lag_2 + heat_wave_lag_3 + o3_lag_1 + o3_lag_2 + o3_lag_3 + no2 + no2_lag_1 + no2_lag_2 + no2_lag_3 + humidity_relative + month + week + year,
    data = data_ps_w_calliper,
    weights = weights
  )

# retrieve the estimate and 95% ci
results_ps_w_calliper_w_cov <- tidy(coeftest(
  model_ps_w_calliper_w_cov,
  vcov. = vcovCL,
  cluster = ~ subclass
),
conf.int = TRUE) %>%
  filter(term == "heat_wave") %>%
  select(term, estimate, conf.low, conf.high) %>%
  mutate_at(vars(estimate:conf.high), ~ round(., 0))

# display results
results_ps_w_calliper_w_cov %>%
  rename(
    "Term" = term,
    "Estimate" = estimate,
    "95% CI Lower Bound" = conf.low,
    "95% CI Upper Bound" = conf.high
  ) %>%
  kable(., align = c("l", "c", "c", "c"))
```

We find that the average effect on the treated is equal to +`r results_ps_w_calliper_w_cov$estimate` years of life lost: the estimate is still very close to the true effect. The 95% confidence interval is consistent with effects ranging from +`r results_ps_w_calliper_w_cov$conf.low` up to +`r results_ps_w_calliper_w_cov$conf.high`. The width of confidence interval is now equal to `r results_ps_w_calliper_w_cov$conf.high - results_ps_w_calliper_w_cov$conf.low`, which is half smaller than the previous interval of `r results_ps_w_calliper$conf.high - results_ps_w_calliper$conf.low`.
